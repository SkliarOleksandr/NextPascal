----------------------------------------------------------------
- МАССИВЫ    
  - Статические массивы
    + array [size] of <type>
  - Динамические массивы
    + константные динамические массивы вида [1, 2, 3]
    + инициализация динамическим масиивов константными динамическими массивами
  + Открытые массивы (только как параметр метода)     
  + автоматическое конвертирование константного массива с вызовом пользовательских 
    операторов implicit определенных в типе элемента массива.
	+ Динамическая проверка диаппазона масиивов (пока только для 1-го измерения)	
	- Системный тип динамического массива с поддержкой not null типов TArray<T>
----------------------------------------------------------------  
- ОПЕРАТОРЫ
  + оператор взятия адреса @
  - оператор разименования ^  
  - in (с набором)
    + in с диапазоном
  - Перегрузка операторов
    + implicit
    - explicit    
    .....  
    +- для структур  
    - операторы в хелперах?
----------------------------------------------------------------
  + initialization section    
  + finalization section
----------------------------------------------------------------
- СТРУКТУРЫ(RECORD)
  + можно обьявлять ссылку на себя внутри без предварительного обьявления
  + инициализация полей (константными значениями)
  + наследование
  + вложенные типы
  + свойства
    + индексные свойства
    + индексные свойства по умолчанию
    - перегрузка индексных свойств       
  + packed
  * МЕТОДЫ
    + inline
    - static
    + class
    + generic-методы
		+ конструктор и деструктор
  - private/public/protected
  - strict private/public/protected     
    
- UNION-СТРУКТУРЫ
  record
    a, b: int32;
    union 
      (v1: int32);
      (v2: int64);
      (v3: Boolean);
    end;      
    union of Boolean
      True: (vv1: int32);
      False: (vv2: int64);
    end;      
  end;  
----------------------------------------------------------------
- КЛАССЫ(CLASS)
  + конструкторы 
  + импорт
  + inherited
    + inherited с уточнением предка
  - static
  - hide (скрытие методов предка)
  + class
  + virtual/override;
	 - проверки несовместимости флагов 
  - virtual class fields
  + слабые ссылки   
	+ ARC
	+- интерфейсы
----------------------------------------------------------------  
- Метаклассы и Метатипы
  + class of  (классовый тип) пример: TMyClass = class of TObject;
  
  - TMetaType (TRTTIType) (любой тип) пример: var T: TMetaType = TObject; 
    в переменную TMetaType можно присвоить любой возможный тип, по сути это аналог PTypeInfo
    но в отличии от него не нужно использовать специальных функций. TMetaType является классом
    для каждого типа компилятор генерирует его под запрашиваемый тип.
----------------------------------------------------------------  
- УКАЗАТЕЛИ/ССЫЛКИ
  + типизированные указатели PType = ^TType
  + нетепизированный указатель pointer
  + nil указатель (nullptr)
	- синоним пустого указателя nil - NULL
  +- нетепизированные ссылки (в параметрах)
  - полноценные ссылки (как аналог в с++)

  ------------------------------------------------------------------------------
  *** новые возможности указателей ***
  ------------------------------------------------------------------------------
  - атрибут nullable
    по умолчанию все ссылочные типы имеют атрибут not null (не указывается явно)
    если в коде есть обращение к переменной/полю с атрибутом nullable то компилятор может:
      1. Выдать предупреждение о возможной ошибке AV
      2. Вставить проверку на nil и не выполнять следующий код если ссылка = nil (как оператор ?. в C#)
    - добавить оператор/функцию аналог ?. в C#
   пример: 
	var ref1: TObject?;  - анлогично var ref1: TObject nullable; 
	var ref2: TObject;  - анлогично var ref2: TObject not null;
	...
	ref1?.method(); 
	или 
	using ref1 r do r.method();
  ------------------------------------------------------------------------------
  - универсальный оператор USING 
	  - для приведения nullable ссылки к not null ссылке
		- для приведения weak ссылки к strong ссылке
		- для приведения ссылки одного типа к другому  
  ------------------------------------------------------------------------------
  - локальные ссылки (спецификатор local) такие ссылки возможно обьявить 
    только как локальные переменные в процедурах и присвоить их можно только в подобные переменные.

  ------------------------------------------------------------------------------
  "weak" ссылка c "триггером":

  TOwner = class
  var
    fChild: TChild; owner for fChild.Owner;
    // когда мы пишем owner for <поле.свойство> то компилятор создет (например)
    // в прологе деструктора код (который сработает когда будет RC = 0),
    // который  проверяет, что если fChild.RC > 1 тогда делается вызов decref
    // для fChild и вызов деструтора прекращается и обьект не удаляется.
    // Теперь только сслыка fChild.Owner владеет данным обьектом.
    // Условие fChild.RC > 1 истенно тогда, когда мы отдали ссылку на fChild
    // еще кудато за пределы TOwner;
  end;

  TChild = class
  private
  var
    fOwner: TOwner owner;
    // может быть только один спецификатор на класс.
    // может проинициализироваться в конструкторе (или быть nil)
    // когда мы пишем owner то компилятор:
    // 1. Не икрементирует RC для данной ссылки (как для weak).
    // 2. в деструкторе код обычный который вызовет decref для fOwner.
  public
    property Owner: TOwner read fOwner;
  end;
  
------------------------------------------------------------------------------
- TABLE (like simple DDL)

  type
    TMyTableRow = record Name, Value: string; end;
 	
	MyTable = table of TMyTableRow (
	  Key1, 'Name1', 'Value1';
 	  Key2, 'Name2', 'Value2';
	  Key3, 'Name3', 'Value3';
	);
	
  ...
    var Name := MyTable[Key2].Name;
	var Value := MyTable[Key2].Value;

	var Name := Key1.Name;
	var Value := Key1.Value;

------------------------------------------------------------------------------
  - параметр self в деструкторе обьявлен как local (чтобы было невозможно получить невалидную ссылку после вызова деструктора)  
    
------------------------------------------------------------------------------
- SET
  + поддержка сетов до 64 бит
  - поддержка сетов более 64 бит  (в делфи максимум 256 бит)
  + include/exclude
  + битовый массив
  - сложение/вычитание сетов
----------------------------------------------------------------
- ОБРАБОТКА ИСКЛЮЧЕНИЙ
  + try finally end
  - try except end
  - try except finally end
  +- raise 
----------------------------------------------------------------
- ЦИКЛЫ
  + while..
  + for ..
    + обьявление цикловой переменной с авто-выводом типа: for var i: int32 = 0 to ...
		+- итерирование по коллекциям: for x in collection do ...
  + break/continue на уровень (0 - текущий, 1 - внешний и т.д.)
  + repeat..until  
  - else секция ???     
     for i := 0 to c do 
     begin
       ...
     end else
       ...;       
----------------------------------------------------------------
- АСИНХРОННОЕ ПРОГРАММИРОВАНИЕ
  - async
  - await
  - ITask<T>
----------------------------------------------------------------  
- ОБОБЩЕННЫЕ ТИПЫ/МЕТОДЫ
  + обобщенные глобальные процедуры/функции
  + обобщенные методы  
  + обобщенные массивы
  + обобщенные параметры могут иметь значение по умолчанию
  +- универсальные алиасы (пока только как внутренний механизм)
  + обобщенные структуры
	+ классы
  - интерфейсы
  - концепты (констрейты)  
  - значения по умолчанию  
  - перегрузка обобщенных типов/методов по кол-ву параметров и их типам.
  - Variadic 
  
----------------------------------------------------------------    
- ПРОЦЕДУРЫ/ФУНКЦИИ
  + модификатор параметра var
  + модификатор параметра const
  + модификатор параметра constref
  - модификатор параметра out 
  + анонимные 
  - замыкания
	+ процедурный тип
	  + TMethod 
		- частичное заполнение параметров (binding) 
  +- вложенные процедуры
  + forward
  + inline
  +- overload   
  +- Чистые (PURE) функции
  +- Внешние (импорт) функции
  +- Экспорт функций
  +- модификатор NORETURN (для оптимизации/предупреждений)
  - модификатор NOEXCEPT(для оптимизации/предупреждений)
----------------------------------------------------------------           
+ WITH
  + алиасы    
  - проверки на одинаковые поля
----------------------------------------------------------------  
- КОНСТРУКЦИИ ВЕТВЛЕНИЯ
  + if ... then ... else
  + iif()  
  + case (пока без оптимизаций)
    + возможность использовать переменные и выражения в сравнениях 
    + диаппазоны
----------------------------------------------------------------    
- ВСТРОЕННЫЕ ТИПЫ
  + NativeInt/NativeUInt
  + конструкция вывода типа TYPE OF от переменной/выражения (возможно сделать функцией typeof())
  + битовый набор SET как статическим массив булевых элементов (array [size] of boolean)
  + SubRange (тип поддиапазон) (TRanged = min..max (предлагается новый синтаксис: [min..max]???)) 
  +- Константы Range-типа (min..max)
  + Pointer
  +- Variant  
  - Int128/UInt128  
  - BigInt
  - Numeric (BigFloat)
  + TGUID 
  - Date
  - Time
  +- DateTime
 --------------------------------------------------------------- 
- ПЕРЕМЕННЫЕ
  + множественное присвоение вида X, Y, Z := SRC; 
  + инициализация локальных переменных при обьявлении(константными значениями)
  +- absolute (пока без проверок типов и пр.)
   - со смещением   
  + inplace-обьявление переменных (с авто выводом типа) 
    + для OUT параметров   
----------------------------------------------------------------
- Разные конструкции  
  - модификаторы переменных/полей
    - readonly  
      для поля класса - нужно инициализировать в констукторе
      для переменной - один раз инициализировать
    - volatile     
  - depricate/obsolete  
  + namespaces (только для деклараций пока)
	+- unsafe секция для небезопастного кода
----------------------------------------------------------------    
- ИНТЕРФЕЙСЫ(interface)
  + свойства
  + импорт
	+ определение GUID-а
 
---------------------------------------------------------------    
- ОБЬЕКТЫ(CLASS)
  - имплементация интерфейсов
  - делегирование имплементации интерфейсов  
  - примеси (mixin)
---------------------------------------------------------------
- УСЛОВНАЯ КОМПИЛЯЦИЯ
  + #define <ID>
  + #undefine <ID>  
  + #ifdef <ID>
  + #ifndef <ID>
  + #else
  + #end
  + #if <boolean expression>
  - #include <file path>
  + #error <text message>
  + #warning <text message>
  + #hint <text message> 
  + #skip (пропуск компиляции модуля)  
  + {$IFDEF}/{$DEFINE}/{$ELSE}/{$ENDIF} (для обратной совместимости с Делфи)
  
  + #macro - описание макросов
  + #emit - вставка исходного кода 
 
  // опции компилятора
  + #set
  + #push 
  + #pop
  - #ifopt

  + #target any/x86/x64/arm32/arm64/js/wasm
---------------------------------------------------------------  
- НАСТРОЙКА СИНТАКСИСА  
  + #TOKEN tokenid symbols; 

---------------------------------------------------------------  
- RTTI 
  + Rtti классы для (тип/процедура/модуль/переменная...) 
  + получение всех модулей сборки
  - получение всех типов модуля
  - получение процедур модуля
  - получение переменных модуля
  
---------------------------------------------------------------  
- BUILT-IN FUNCTIONS
  + current_unit
  + current_function
  + current_line: integer    
  + TypeName(var or type literal): 
  + SizeOf(type or variable)  
  + Length(array type)
  + SetLength(array type)
  + new
  + free(delete)  
  + Assigned(obj: reference): boolean;
  + Assert()
  + GetRef(WeakRef: reference; out StrongRef: reference): Boolean;
  + include(set, subset);
  + exclude(set, subset);
  + TypeInfo(): TRTTI
  + GetCallStack(): TCallStack;
  + Now(): TDateTime;
  - defined(define literal): boolean;
  - GetVirtualMethodIndex(Method): Integer;
  - GetVirtualMethodPtr(Instance: TObject; Index): Pointer;    
  - GetInterfaceMethodIndex(Method): Integer;	
  
----------------------------------------------------------------